{
  "version": 3,
  "sources": ["../../b-spline/index.js"],
  "sourcesContent": ["\n\nfunction interpolate(t, degree, points, knots, weights, result) {\n\n  var i,j,s,l;              // function-scoped iteration variables\n  var n = points.length;    // points count\n  var d = points[0].length; // point dimensionality\n\n  if(degree < 1) throw new Error('degree must be at least 1 (linear)');\n  if(degree > (n-1)) throw new Error('degree must be less than or equal to point count - 1');\n\n  if(!weights) {\n    // build weight vector of length [n]\n    weights = [];\n    for(i=0; i<n; i++) {\n      weights[i] = 1;\n    }\n  }\n\n  if(!knots) {\n    // build knot vector of length [n + degree + 1]\n    var knots = [];\n    for(i=0; i<n+degree+1; i++) {\n      knots[i] = i;\n    }\n  } else {\n    if(knots.length !== n+degree+1) throw new Error('bad knot vector length');\n  }\n\n  var domain = [\n    degree,\n    knots.length-1 - degree\n  ];\n\n  // remap t to the domain where the spline is defined\n  var low  = knots[domain[0]];\n  var high = knots[domain[1]];\n  t = t * (high - low) + low;\n\n  if(t < low || t > high) throw new Error('out of bounds');\n\n  // find s (the spline segment) for the [t] value provided\n  for(s=domain[0]; s<domain[1]; s++) {\n    if(t >= knots[s] && t <= knots[s+1]) {\n      break;\n    }\n  }\n\n  // convert points to homogeneous coordinates\n  var v = [];\n  for(i=0; i<n; i++) {\n    v[i] = [];\n    for(j=0; j<d; j++) {\n      v[i][j] = points[i][j] * weights[i];\n    }\n    v[i][d] = weights[i];\n  }\n\n  // l (level) goes from 1 to the curve degree + 1\n  var alpha;\n  for(l=1; l<=degree+1; l++) {\n    // build level l of the pyramid\n    for(i=s; i>s-degree-1+l; i--) {\n      alpha = (t - knots[i]) / (knots[i+degree+1-l] - knots[i]);\n\n      // interpolate each component\n      for(j=0; j<d+1; j++) {\n        v[i][j] = (1 - alpha) * v[i-1][j] + alpha * v[i][j];\n      }\n    }\n  }\n\n  // convert back to cartesian and return\n  var result = result || [];\n  for(i=0; i<d; i++) {\n    result[i] = v[s][i] / v[s][d];\n  }\n\n  return result;\n}\n\n\nmodule.exports = interpolate;\n"],
  "mappings": ";;;;;AAAA;AAAA;AAEA,aAAS,YAAY,GAAG,QAAQ,QAAQ,OAAO,SAAS,QAAQ;AAE9D,UAAI,GAAE,GAAE,GAAE;AACV,UAAI,IAAI,OAAO;AACf,UAAI,IAAI,OAAO,CAAC,EAAE;AAElB,UAAG,SAAS;AAAG,cAAM,IAAI,MAAM,oCAAoC;AACnE,UAAG,SAAU,IAAE;AAAI,cAAM,IAAI,MAAM,sDAAsD;AAEzF,UAAG,CAAC,SAAS;AAEX,kBAAU,CAAC;AACX,aAAI,IAAE,GAAG,IAAE,GAAG,KAAK;AACjB,kBAAQ,CAAC,IAAI;AAAA,QACf;AAAA,MACF;AAEA,UAAG,CAAC,OAAO;AAET,YAAI,QAAQ,CAAC;AACb,aAAI,IAAE,GAAG,IAAE,IAAE,SAAO,GAAG,KAAK;AAC1B,gBAAM,CAAC,IAAI;AAAA,QACb;AAAA,MACF,OAAO;AACL,YAAG,MAAM,WAAW,IAAE,SAAO;AAAG,gBAAM,IAAI,MAAM,wBAAwB;AAAA,MAC1E;AAEA,UAAI,SAAS;AAAA,QACX;AAAA,QACA,MAAM,SAAO,IAAI;AAAA,MACnB;AAGA,UAAI,MAAO,MAAM,OAAO,CAAC,CAAC;AAC1B,UAAI,OAAO,MAAM,OAAO,CAAC,CAAC;AAC1B,UAAI,KAAK,OAAO,OAAO;AAEvB,UAAG,IAAI,OAAO,IAAI;AAAM,cAAM,IAAI,MAAM,eAAe;AAGvD,WAAI,IAAE,OAAO,CAAC,GAAG,IAAE,OAAO,CAAC,GAAG,KAAK;AACjC,YAAG,KAAK,MAAM,CAAC,KAAK,KAAK,MAAM,IAAE,CAAC,GAAG;AACnC;AAAA,QACF;AAAA,MACF;AAGA,UAAI,IAAI,CAAC;AACT,WAAI,IAAE,GAAG,IAAE,GAAG,KAAK;AACjB,UAAE,CAAC,IAAI,CAAC;AACR,aAAI,IAAE,GAAG,IAAE,GAAG,KAAK;AACjB,YAAE,CAAC,EAAE,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,IAAI,QAAQ,CAAC;AAAA,QACpC;AACA,UAAE,CAAC,EAAE,CAAC,IAAI,QAAQ,CAAC;AAAA,MACrB;AAGA,UAAI;AACJ,WAAI,IAAE,GAAG,KAAG,SAAO,GAAG,KAAK;AAEzB,aAAI,IAAE,GAAG,IAAE,IAAE,SAAO,IAAE,GAAG,KAAK;AAC5B,mBAAS,IAAI,MAAM,CAAC,MAAM,MAAM,IAAE,SAAO,IAAE,CAAC,IAAI,MAAM,CAAC;AAGvD,eAAI,IAAE,GAAG,IAAE,IAAE,GAAG,KAAK;AACnB,cAAE,CAAC,EAAE,CAAC,KAAK,IAAI,SAAS,EAAE,IAAE,CAAC,EAAE,CAAC,IAAI,QAAQ,EAAE,CAAC,EAAE,CAAC;AAAA,UACpD;AAAA,QACF;AAAA,MACF;AAGA,UAAI,SAAS,UAAU,CAAC;AACxB,WAAI,IAAE,GAAG,IAAE,GAAG,KAAK;AACjB,eAAO,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC;AAAA,MAC9B;AAEA,aAAO;AAAA,IACT;AAGA,WAAO,UAAU;AAAA;AAAA;",
  "names": []
}
